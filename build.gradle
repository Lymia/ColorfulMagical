plugins {
	id "architectury-plugin" version "3.4.151" apply false
	id 'dev.architectury.loom' version '1.4.380' apply false
	id 'org.ajoberstar.grgit' version '5.0.0'
	id 'com.github.johnrengelman.shadow' version "8.1.1"
	id "io.github.sgtsilvio.gradle.proguard" version "0.6.0"
	id "scala"
}

allprojects {
	apply plugin: "java"
	apply plugin: "scala"
	apply plugin: "idea"
	apply plugin: 'application'
	apply plugin: 'com.github.johnrengelman.shadow'
	apply plugin: 'io.github.sgtsilvio.gradle.proguard'

	sourceCompatibility = JavaVersion.VERSION_1_8
	targetCompatibility = JavaVersion.VERSION_1_8

	version = "${project.mod_version}${getVersionMetadata()}+mc${project.minecraft_version}"
	group = project.maven_group

	repositories {
		mavenCentral()
		maven {
			url "https://maven.architectury.dev/"
		}
		maven {
			url "https://cursemaven.com"
			content {
				includeGroup "curse.maven"
			}
		}
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.encoding = "UTF-8"
	}

	java {
		withSourcesJar()
	}

	dependencies {
		implementation "org.scala-lang:scala3-library_3:${rootProject.scala_version}"
	}

	jar {
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	}

	shadowJar {
		exclude "META-INF/maven/**"
		exclude "META-INF/proguard/**"
		exclude "META-INF/versions/**"
		exclude "META-INF/services/**"

		// weird useless resources that get through
		exclude "org/jdesktop/swingx/**/resources/**"
		exclude "org/jdesktop/swingx/**/*.gif"
		exclude "org/jdesktop/swingx/**/*.png"
		exclude "**/*.gwt.xml"

		// scala
		exclude "LICENSE"
		exclude "NOTICE"
		exclude "rootdoc.txt"
		exclude "library.properties"
		exclude "**/*.tasty"
	}

	dependencies {
		// newest version of proguard that doesn't keep 1MB worth of Scala library for no reason.
		proguardClasspath("com.guardsquare:proguard-base:7.4.1")
	}

	task('proguardJar', type: io.github.sgtsilvio.gradle.proguard.ProguardTask) {
		addInput {
			classpath.from(tasks.shadowJar)
		}
		addOutput {
			archiveFile.set(base.libsDirectory.file("proguard-temp-${version}.jar"))
		}
        addLibrary {
            classpath.from(sourceSets.main.compileClasspath)
        }
		mappingFile.set(base.libsDirectory.file("${project.name}-${project.version}-mapping.txt"))

		// JVM library jars
		if (new File("/usr/lib/jvm/java-8-openjdk/jre/lib/").exists()) {
			addLibrary {classpath.from("/usr/lib/jvm/java-8-openjdk/jre/lib/rt.jar") }
		} else {
			jdkModules.add "java.base"
			jdkModules.add "java.datatransfer"
			jdkModules.add "java.desktop"
			jdkModules.add "java.logging"
			jdkModules.add "java.naming"
			jdkModules.add "java.prefs"
			jdkModules.add "java.sql"
			jdkModules.add "jdk.unsupported"
		}

		rules.addAll(
				"-verbose",
				"-dontwarn **",
				"-skipnonpubliclibraryclasses",

				"-keep class moe.lymia.** { <methods>; }",
				"-keep class moe.lymia.**.api.** { <fields>; <methods>; }",
				"-keepattributes SourceFile,LineNumberTable,*Annotation*",

				"-repackageclasses ${project.shadow_prefix}",

                "-optimizationpasses 5",
                "-optimizations !code/simplification/*", // something in that optimization causes an error in proguard
				"-optimizeaggressively",
		)
	}
}

def getVersionMetadata() {
	// CI builds only
	if (grgit != null) {
		def head = grgit.head()

		if (grgit.tag.list().findAll { it.commit == head}.isEmpty()) {
			def id = head.abbreviatedId
			if (!grgit.status().clean) {
				id += ".dirty"
			}
			return "-r${id}"
		} else {
			return ""
		}
	}

	// No tracking information could be found about the build
	return "-unknown"
}